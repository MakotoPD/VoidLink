use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::sync::{LazyLock, Mutex};
use tauri::Emitter;
use tauri_plugin_shell::ShellExt;
use tauri_plugin_shell::process::CommandEvent;

// Global state for tracking running FRP processes
pub static FRP_PROCESSES: LazyLock<Mutex<HashMap<String, FRPProcess>>> = LazyLock::new(|| Mutex::new(HashMap::new()));


#[derive(Debug, Clone)]
pub struct FRPProcess {
    pub tunnel_id: String,
    pub pid: Option<u32>,
    pub is_running: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FRPConfig {
    pub server_addr: String,
    pub server_port: u16,
    pub token: String,
    pub proxies: Vec<FRPProxy>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FRPProxy {
    pub name: String,
    pub proxy_type: String, // "tcp" or "udp"
    pub local_port: u16,
    pub remote_port: u16,
}

#[derive(Debug, Serialize)]
pub struct FRPStatus {
    pub tunnel_id: String,
    pub is_running: bool,
    pub pid: Option<u32>,
}

#[derive(Debug, Serialize)]
pub struct FRPStartResult {
    pub success: bool,
    pub tunnel_id: String,
    pub message: String,
}

fn get_frp_config_dir() -> PathBuf {
    let docs = dirs::document_dir().unwrap_or_else(|| PathBuf::from("."));
    docs.join("VoidLink").join("frp")
}

fn write_frp_config(tunnel_id: &str, config: &FRPConfig) -> Result<PathBuf, String> {
    let config_dir = get_frp_config_dir();
    fs::create_dir_all(&config_dir).map_err(|e| format!("Failed to create config dir: {}", e))?;
    
    let config_path = config_dir.join(format!("{}.toml", tunnel_id));
    
    let mut toml_content = String::new();
    toml_content.push_str("# FRP Client Configuration - Generated by VoidLink\n\n");
    toml_content.push_str("[common]\n");
    toml_content.push_str(&format!("server_addr = \"{}\"\n", config.server_addr));
    toml_content.push_str(&format!("server_port = {}\n", config.server_port));
    toml_content.push_str(&format!("token = \"{}\"\n", config.token));
    toml_content.push_str("\n");
    
    for proxy in &config.proxies {
        toml_content.push_str(&format!("[{}]\n", proxy.name));
        toml_content.push_str(&format!("type = \"{}\"\n", proxy.proxy_type));
        toml_content.push_str("local_ip = \"127.0.0.1\"\n");
        toml_content.push_str(&format!("local_port = {}\n", proxy.local_port));
        toml_content.push_str(&format!("remote_port = {}\n", proxy.remote_port));
        toml_content.push_str("\n");
    }
    
    fs::write(&config_path, toml_content)
        .map_err(|e| format!("Failed to write config: {}", e))?;
    
    Ok(config_path)
}

#[tauri::command]
pub async fn frp_start_tunnel(
    app: tauri::AppHandle,
    tunnel_id: String,
    config: FRPConfig,
) -> Result<FRPStartResult, String> {
    // Check if already running
    {
        let processes = FRP_PROCESSES.lock().map_err(|e| e.to_string())?;
        if let Some(proc) = processes.get(&tunnel_id) {
            if proc.is_running {
                return Ok(FRPStartResult {
                    success: false,
                    tunnel_id,
                    message: "Tunnel is already running".to_string(),
                });
            }
        }
    }
    
    // Write config file
    let config_path = write_frp_config(&tunnel_id, &config)?;
    let config_path_str = config_path.to_string_lossy().to_string();
    
    log::info!("Starting FRP tunnel {} with config: {}", tunnel_id, config_path_str);
    
    // Spawn FRP client using sidecar
    let shell = app.shell();
    
    // Use the sidecar command
    let (mut rx, child) = shell
        .sidecar("frpc")
        .map_err(|e| format!("Failed to create sidecar command: {}", e))?
        .args(["-c", &config_path_str])
        .spawn()
        .map_err(|e| format!("Failed to spawn frpc: {}", e))?;
    
    let pid = child.pid();
    let tunnel_id_clone = tunnel_id.clone();
    
    // Store process info
    {
        let mut processes = FRP_PROCESSES.lock().map_err(|e| e.to_string())?;
        processes.insert(tunnel_id.clone(), FRPProcess {
            tunnel_id: tunnel_id.clone(),
            pid: Some(pid),
            is_running: true,
        });
    }
    
    // Spawn task to monitor output
    let app_clone = app.clone();
    tauri::async_runtime::spawn(async move {
        while let Some(event) = rx.recv().await {
            match event {
                CommandEvent::Stdout(line) => {
                    let line_str = String::from_utf8_lossy(&line);
                    log::info!("[FRP {}] {}", tunnel_id_clone, line_str);
                    let _ = app_clone.emit("frp-output", serde_json::json!({
                        "tunnel_id": tunnel_id_clone,
                        "type": "stdout",
                        "message": line_str.to_string()
                    }));
                    
                    // Check for connection success
                    if line_str.contains("start proxy success") || line_str.contains("proxy added") {
                        let _ = app_clone.emit("frp-connected", serde_json::json!({
                            "tunnel_id": tunnel_id_clone
                        }));
                    }
                }
                CommandEvent::Stderr(line) => {
                    let line_str = String::from_utf8_lossy(&line);
                    log::error!("[FRP {}] {}", tunnel_id_clone, line_str);
                    let _ = app_clone.emit("frp-output", serde_json::json!({
                        "tunnel_id": tunnel_id_clone,
                        "type": "stderr",
                        "message": line_str.to_string()
                    }));
                }
                CommandEvent::Terminated(payload) => {
                    log::info!("[FRP {}] Process terminated with code: {:?}", tunnel_id_clone, payload.code);
                    
                    // Update state
                    if let Ok(mut processes) = FRP_PROCESSES.lock() {
                        if let Some(proc) = processes.get_mut(&tunnel_id_clone) {
                            proc.is_running = false;
                        }
                    }
                    
                    let _ = app_clone.emit("frp-stopped", serde_json::json!({
                        "tunnel_id": tunnel_id_clone,
                        "code": payload.code
                    }));
                    break;
                }
                _ => {}
            }
        }
    });
    
    Ok(FRPStartResult {
        success: true,
        tunnel_id,
        message: "Tunnel started".to_string(),
    })
}

#[tauri::command]
pub async fn frp_stop_tunnel(tunnel_id: String) -> Result<bool, String> {
    let mut processes = FRP_PROCESSES.lock().map_err(|e| e.to_string())?;
    
    if let Some(proc) = processes.get_mut(&tunnel_id) {
        if !proc.is_running {
            return Ok(false);
        }
        
        if let Some(pid) = proc.pid {
            // Kill the process
            #[cfg(windows)]
            {
                let _ = std::process::Command::new("taskkill")
                    .args(["/F", "/PID", &pid.to_string()])
                    .output();
            }
            
            #[cfg(not(windows))]
            {
                let _ = std::process::Command::new("kill")
                    .args(["-9", &pid.to_string()])
                    .output();
            }
        }
        
        proc.is_running = false;
        
        // Clean up config file
        let config_dir = get_frp_config_dir();
        let config_path = config_dir.join(format!("{}.toml", tunnel_id));
        let _ = fs::remove_file(config_path);
        
        log::info!("Stopped FRP tunnel: {}", tunnel_id);
        Ok(true)
    } else {
        Ok(false)
    }
}

#[tauri::command]
pub fn frp_get_status(tunnel_id: String) -> Result<FRPStatus, String> {
    let processes = FRP_PROCESSES.lock().map_err(|e| e.to_string())?;
    
    if let Some(proc) = processes.get(&tunnel_id) {
        Ok(FRPStatus {
            tunnel_id: proc.tunnel_id.clone(),
            is_running: proc.is_running,
            pid: proc.pid,
        })
    } else {
        Ok(FRPStatus {
            tunnel_id,
            is_running: false,
            pid: None,
        })
    }
}

/// Kill all running FRP tunnels - called on app exit
pub fn stop_all_tunnels() {
    if let Ok(mut processes) = FRP_PROCESSES.lock() {
        for (tunnel_id, proc) in processes.iter_mut() {
            if proc.is_running {
                if let Some(pid) = proc.pid {
                    log::info!("Stopping FRP tunnel {} (PID: {})", tunnel_id, pid);
                    #[cfg(windows)]
                    {
                        let _ = std::process::Command::new("taskkill")
                            .args(["/F", "/PID", &pid.to_string()])
                            .output();
                    }
                    #[cfg(not(windows))]
                    {
                        let _ = std::process::Command::new("kill")
                            .args(["-9", &pid.to_string()])
                            .output();
                    }
                }
                proc.is_running = false;
            }
        }
        
        // Clean up all config files
        let config_dir = get_frp_config_dir();
        if let Ok(entries) = std::fs::read_dir(&config_dir) {
            for entry in entries.flatten() {
                if entry.path().extension().map_or(false, |e| e == "toml") {
                    let _ = std::fs::remove_file(entry.path());
                }
            }
        }
    }
}

